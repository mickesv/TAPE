TAPE
====
Tool for Automated Performance Evaluations

* Introduction
This is a tool (actually a set of tools) to conduct performance analysis of a C/C++ program on code/design/architecture levels, using static code analysis.
The tools are built on top of clang/llvm.

* Overall structure
  The overall structure follows a cycle of Extract-Parse-Analyse-Visualise.
  This is done in a set of different executables, as follows:

  - codeext
    - Extract
    - Parse
  - granalyse
    - Analyse
  - grmaker
    - Visualise
* Input and Output
** config.cfg
   All programmes use the same config-file for a particular project. These are simple "key=value"-files. A key can have multiple values, these are then comma-separated.

   A special case is "file", which is one line per file. I had a weird idea that this would make it easier to auto-generate this part of the file eventually.

** output.csv
   A comma-separated list of relations found during extraction and analysis. The format is:

   relation;source;target;key1=value,key2=value [,...]

   the relations are defined in nodetypes.hh. Source and target are integers, and the key=value part can be of any type.

** output.dot
   Generated by grmaker for visualisation with graphviz.

* Design
** Helper classes
   - StringStuff: string manipulations
   - CSVfile: read/write csv-file
   - Debug: for output; all print-methods are keyed with a debugLevel, to be able to set the verbocity of the output.
   - Config: reads the .cfg-file and keeps the configuration ready at hand.

** Model classes
   - Model, ModelNode (both declared in Model.hh): The basic Model of a programme (all the relations). When you read a model from a file, this is all you ought to need.
   - basicnodetypes.hh: all the fundamental relations found in a C/C++ program. You can define parser-specific nodetypes as well, but they are put together with the parser declaration.
   - nodetypes.hh: just to keep an overview of all the available relation types, I put these in a separate file. I am not entirely happy about this, but I'll keep it like this for now.

** Code Extraction Classes
   - Extractor: extracts static relations, and contains the visitor that goes through each function.
   - Parser: abstract base class for all the parsers that actually extract stuff from the functions.
   - *Parser: Various parsers.
   - getParsers.hh: loads the appropriate parsers (as requested in the cfg-file)

** Other
   - ComponentMaker: Analyses the relations and tries to automatically structure the system into components
   - GraphMaker: Generates .dot-output
   - todo.txt : running notes of what to do and where.

* The Extract/Parse loop
  codeext.cc starts the extract/parse cycle.
  During the extract-phase, each file is inspected by the Extractor::extractDeclarations method, and static relations such as function/method/class/attribute/global variable declarations and class inheritance and stuff is extracted.
  During the parse-cycle, each function is visited, and the set of parsers is applied. At the start of a function each parser's startFunction method is called, and at the end, the endFunction method is called. This enables the parsers to do pre-and-post processing.
  During the parse of a function, the parse-method of each parser is called in turn.
  The parsers have access to a ParserData-object, where they can throw in key=value data for themselves or for other parsers to look at. For example, the FunctionCallParser annotates a functioncall with the loopdepth that the LoopDepthParser stores in the ParserData object. this object is recreated for every new function, so it is not a persistent storage bin.

  Parsing relies heavily on the CXCursor.kind enum, but *can* also be done differently.
  http://clang.llvm.org/doxygen/Index_8h.html and in particular
  http://clang.llvm.org/doxygen/group__CINDEX.html#gaaccc432245b4cd9f2d470913f9ef0013
  will be visited quite often when constructing a parser.

  to keep track of compound statements, the Parser class provides the methods "descendCompound" and "ascendCompound". For an example of how to use them, please see LoopdepthParser.cc

* granalyse
  The intention of this program is to include all types of analysis done on a higher level than the code-level. So you would make sure that you have the right parsers in place, and then use this program to analyse e.g. for classes-as-used (as opposed the static classes-as-declared), components, and performance improvements based on this.
  At the moment, this program is not written with extensibility in mind, but as future work, I suggest to do this in the same way as with the parsers (config-file, extensible set of analysis types).


