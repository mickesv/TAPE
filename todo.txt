/* TODO
 * - Add linkage to functioncalls
 * - Have another go at StringStuff
 * - !!! Fix stack/heap usage everywhere... I've become Java-sloppy...
 * - Document how to create a new parser (=inherit from Parser, add to getParsers, add to config file, usage of ParserData*)
 */


DONE 2013-01-17: Fix bug in model/csvread when comment-field contains double equal signs, e.g. "operator==". This gets split and interpreted in the wrong way.

DONE 2013-01-18: Find C++ Classes
DONE 2013-01-18: Find C++ Methods
DONE 2013-01-18: Find C++ Attributes
DONE 2013-01-18: Parse C++ Methods
DONE 2013-01-25: Fix lookup so that C++ methods are found when looking for a method call.
    One way to do this would be to create a new parser: CPlusPlusFunctionCallParser, that keeps track of variable declarations to keep track of the ones that are of "my" classes (and their types). Recurse into clang_callExpr, and a DeclRefExpr will show up to this variable, and then I can look up its type and find the right call.
    NOT NECESSARY: clang_getCursorSemanticParent(clang_getCursorReferenced(theCursor))) marks the spot.
DONE 2013-01-25: First attempt at making a decent class graph in GraphViz.
DONE 2013-01-29 Inheritance should create a node as well. ... or at least an attribute
DONE? 2013-01-29 Make sure that all hh-files are parsed first, to avoid the situation where class names are not found. Alternatively, run through the extraction phase twice to make sure that whatever is missed the first time gets caught the next time.
DONE 2013-01-29 Implement second extractor pass on those posts that have a -1 in them...
DONE 2013-01-29 Tidy up grmaker so that class scope is printed as well when I only print methods (and do not use the option "classes")
DONE 2013-02-21 Strange method names messes up the dot file (e.g. "operator<"). Need to parse and escape everything before putting it into the dot...
DONE 2013-03-06 Create a "VerboseParser" that does nothing but print out everything and recurse everything. This will be useful when creating new parsers and trying to figure out what is going on in a program.

--------------------

AttributeAccessParser

Overridden methods, try this one: CINDEX_LINKAGE void clang_getOverriddenCursors 	( 	CXCursor  	cursor,
		CXCursor **  	overridden,
		unsigned *  	num_overridden 
	) 		

move function codeext.cc::secondPass into Extractor class


clang_getInclusions (CXTranslationUnit tu, CXInclusionVisitor visitor, CXClientData client_data)
 	Visit the set of preprocessor inclusions in a translation unit. The visitor function is called with the provided data for every included file. This does not include headers included by the PCH file (unless one is inspecting the inclusions in the PCH file itself). 

Make extractors pluggable as well (as with the parsers) so there is CExtractor, CPPExtractor, PPExtractor


Notes on call chain parser:
 When I hit a statement, record the range of it and push on a stack. If it is a call chain, it will be recursed step by step, and I can (probably) use "isWithinCurrentCompound"  (or something similar) to check whether I am still within the top of the stack. If I am (and I also need to exclude the possibility that I have actually descended into a compound), I can then start counting "->" and "." tokens (that I get from clang_tokenize()).

 2013-03-25 ---
 The line:
   theC.c->ff(foo())->t();
 gets parsed as:
Verbose: (122,3) CallExpr:t:Void
Verbose:  Range start 122,3 end 122,25
Verbose:  Tokens: #theC#.#c#->#ff#(#foo#(#)#)#->#t#(#)#;#
Verbose: (122,22) MemberRefExpr:t:Unexposed
Verbose:  Range start 122,3 end 122,23
Verbose:  Tokens: #theC#.#c#->#ff#(#foo#(#)#)#->#t#(#
Verbose: (122,3) CallExpr:ff:Pointer
Verbose:  Range start 122,3 end 122,20
Verbose:  Tokens: #theC#.#c#->#ff#(#foo#(#)#)#->#
Verbose: (122,11) MemberRefExpr:ff:Unexposed
Verbose:  Range start 122,3 end 122,13
Verbose:  Tokens: #theC#.#c#->#ff#(#
Verbose: (122,8) UnexposedExpr:c:Pointer
Verbose:  Range start 122,3 end 122,9
Verbose:  Tokens: #theC#.#c#->#
Verbose: (122,8) MemberRefExpr:c:Pointer
Verbose:  Range start 122,3 end 122,9
Verbose:  Tokens: #theC#.#c#->#
Verbose: (122,3) DeclRefExpr:theC:Record
Verbose:  Range start 122,3 end 122,7
Verbose:  Tokens: #theC#.#
Verbose: (122,14) CallExpr:foo:Int
Verbose:  Range start 122,14 end 122,19
Verbose:  Tokens: #foo#(#)#)#
Verbose: (122,14) UnexposedExpr:foo:Pointer
Verbose:  Range start 122,14 end 122,17
Verbose:  Tokens: #foo#(#
Verbose: (122,14) DeclRefExpr:foo:FunctionProto
Verbose:  Range start 122,14 end 122,17
Verbose:  Tokens: #foo#(#

 This is nice. This means that clang first takes care of the "outer" statement (theC.c->ff()->t()) and *then* deals with the "inner" statements. So: if I see a callExpr that contains "->" and "." tokens, I push this onto a que, and then take care of all other statements that are within this source range. Once I hit something outside the range, I am done with this full statement. Take the first element of the queue and blank out all the bits covered by subsequent elements. What remains is one call chain. Remove first element and re-do with the new first element of the queue.
 "blank out all the bits": This is slightly tricky because I may have several chains of tokens that look the same. (ex: q(a->b->c())->w(a->b->c()) will have two elements in the queue with the tokens for a->b->c() ). On the other hand; it does not matter since I do not need to follow the calls or anything, I just need to count the "->" and "."'s, and this count will be the same in any case.
 ---


Notes on read or write of variables:
 Since I can tokenize statements, I can also start looking for what is an assignment and what is not.
 ... There is also a clue in that clang deals with the left-hand-side first, and then moves on to the right-hand side. Within each side, the order is then right to left (to resolve call chains). This leaves hints in the position of the current cursor. On the other hand, there is only one of the left-hand-sides that is actually being written to; the rest are just read.
